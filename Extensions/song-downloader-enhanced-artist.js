!async function(){for(;!Spicetify.React||!Spicetify.ReactDOM;)await new Promise(i=>setTimeout(i,10));var i;i=async function(){for(;null==Spicetify||!Spicetify.showNotification;)await new Promise(i=>setTimeout(i,100));async function startServerIfNeeded() {try {const response = await fetch('http://localhost:3001/health');if (response.ok) return;} catch (e) {}try {const { exec } = require('child_process');const path = require('path');const extensionsPath = path.join(require('os').homedir(), 'AppData', 'Roaming', 'spicetify', 'Extensions');const managerPath = path.join(extensionsPath, 'server-manager.js');exec(`node "${managerPath}" --start`, (error, stdout, stderr) => {if (error) {console.error('Failed to start server:', error);} else {console.log('Server manager:', stdout);}});} catch (e) {console.warn('Could not auto-start server:', e);}}function getAccessToken() {try {return Spicetify.Platform.AuthorizationAPI._tokenProvider?._token?.accessToken || Spicetify.Platform.AuthorizationAPI.getToken?.()?.access_token || null;} catch (e) {console.warn('Could not get access token:', e);return null;}}async function downloadContent(uri, metadata) {const url = Spicetify.URI.fromString(uri).toURL();let type, name;if (Spicetify.URI.isTrack(uri)) {type = 'track';name = `${metadata?.title || metadata?.name || 'Unknown'} by ${metadata?.artist_name || metadata?.artists?.[0]?.name || 'Unknown'}`;} else if (Spicetify.URI.isPlaylist(uri)) {type = 'playlist';name = metadata?.name || 'Unknown Playlist';} else if (Spicetify.URI.isAlbum(uri)) {type = 'album';name = `${metadata?.name || 'Unknown Album'} by ${metadata?.artist_name || metadata?.artists?.[0]?.name || 'Unknown Artist'}`;} else if (Spicetify.URI.isArtist(uri)) {type = 'artist';name = metadata?.name || 'Unknown Artist';}try {const accessToken = getAccessToken();if (type === 'album' || type === 'playlist' || type === 'artist') {Spicetify.showNotification(`Starting enhanced ${type} download: ${name}`, false, 3000);} else {Spicetify.showNotification(`Starting ${type} download: ${name}`, false, 3000);}const response = await fetch('http://localhost:3001/download', {method: 'POST',headers: {'Content-Type': 'application/json'},body: JSON.stringify({url, type, name, accessToken})});const result = await response.json();if (result.success) {Spicetify.showNotification(`${type} download completed successfully!`, false, 3000);} else {throw new Error(result.error || 'Download failed');}} catch (error) {if (error.message.includes('fetch')) {await startServerIfNeeded();await new Promise(resolve => setTimeout(resolve, 3000));try {const accessToken = getAccessToken();const response = await fetch('http://localhost:3001/download', {method: 'POST',headers: {'Content-Type': 'application/json'},body: JSON.stringify({url, type, name, accessToken})});const result = await response.json();if (result.success) {Spicetify.showNotification(`${type} download completed successfully!`, false, 3000);} else {throw new Error(result.error || 'Download failed');}} catch (retryError) {Spicetify.showNotification(`Download failed: ${retryError.message}`, true, 5000);}} else {Spicetify.showNotification(`Download failed: ${error.message}`, true, 5000);}console.error('Download error:', error);}}async function getTrackMetadata(trackId) {try {const accessToken = getAccessToken();const response = await fetch(`https://api.spotify.com/v1/tracks/${trackId}`, {headers: {'Authorization': `Bearer ${accessToken}`}});if (response.ok) {const track = await response.json();return {title: track.name, artist_name: track.artists?.[0]?.name, artists: track.artists};}} catch (e) {console.warn('Failed to get track metadata from API:', e);}return {title: 'Unknown', artist_name: 'Unknown'};}async function getAlbumMetadata(albumId) {try {const accessToken = getAccessToken();const response = await fetch(`https://api.spotify.com/v1/albums/${albumId}`, {headers: {'Authorization': `Bearer ${accessToken}`}});if (response.ok) {const album = await response.json();return {name: album.name, artist_name: album.artists?.[0]?.name, artists: album.artists};}} catch (e) {console.warn('Failed to get album metadata from API:', e);}return {name: 'Unknown Album', artist_name: 'Unknown Artist'};}async function getArtistMetadata(artistId) {try {const accessToken = getAccessToken();const response = await fetch(`https://api.spotify.com/v1/artists/${artistId}`, {headers: {'Authorization': `Bearer ${accessToken}`}});if (response.ok) {const artist = await response.json();return {name: artist.name};}} catch (e) {console.warn('Failed to get artist metadata from API:', e);}return {name: 'Unknown Artist'};}new Spicetify.ContextMenu.Item("Download", async function(uris) {const uri = uris[0];let metadata = {};if (Spicetify.URI.isTrack(uri)) {const trackId = Spicetify.URI.fromString(uri).id;metadata = await getTrackMetadata(trackId);} else if (Spicetify.URI.isPlaylist(uri)) {try {const playlist = await Spicetify.Platform.PlaylistAPI.getPlaylist(Spicetify.URI.fromString(uri).id);metadata = {name: playlist.name};} catch (e) {metadata = {name: 'Unknown Playlist'};}} else if (Spicetify.URI.isAlbum(uri)) {const albumId = Spicetify.URI.fromString(uri).id;metadata = await getAlbumMetadata(albumId);} else if (Spicetify.URI.isArtist(uri)) {const artistId = Spicetify.URI.fromString(uri).id;metadata = await getArtistMetadata(artistId);}await downloadContent(uri, metadata);}, function(uris) {const uri = uris[0];return Spicetify.URI.isTrack(uri) || Spicetify.URI.isPlaylist(uri) || Spicetify.URI.isAlbum(uri) || Spicetify.URI.isArtist(uri);}).register();await startServerIfNeeded();},(async()=>{await i()})()}();
